OUTPUT_FORMAT(elf32-littlearm)
OUTPUT_ARCH(arm)
ENTRY(_start)

MEMORY
{
    RAM     : ORIGIN = 0x20000000,	LENGTH = 128K
    FLASH   : ORIGIN = 0x08000000,	LENGTH = 1M
    SRAM    : ORIGIN = 0x68000000,	LENGTH = 2M
}

__Main_Stack_Size = 1024 ;

__stack = ORIGIN(RAM) + LENGTH(RAM);

_estack = __stack; 	/* STM specific definition */

SECTIONS
{
    .isr : ALIGN(4)
    {
        FILL(0xFF)
        
        KEEP(*(.isr_vector))     		/* Interrupt vectors */
		*(.after_vectors .after_vectors.*)	/* Startup code and ISR */
        *(.text .text.*) 
        *(.rodata .rodata*)  
        
		/*
		 * Stub sections generated by the linker, to glue together 
		 * ARM and Thumb code. .glue_7 is used for ARM code calling 
		 * Thumb code, and .glue_7t is used for Thumb code calling 
		 * ARM code. Apparently always generated by the linker, for some
		 * architectures, so better leave them here.
		 */
        *(.glue_7)
        *(.glue_7t)
    } >FLASH
    
    /* ARM magic sections */
	.ARM.extab : ALIGN(4)
   	{
       *(.ARM.extab* .gnu.linkonce.armextab.*)
   	} > FLASH
   	
    . = ALIGN(4);
   	__exidx_start = .;   	
   	.ARM.exidx : ALIGN(4)
   	{
       *(.ARM.exidx* .gnu.linkonce.armexidx.*)
   	} > FLASH
   	
	__exidx_end = .;
   	
    . = ALIGN(4);
    _etext = .;
    __etext = .;
    
    .hk : ALIGN(4)
    {
    	. = ALIGN(4); 
    	_hk_lma = LOADADDR(.hk);
    	 _shk = .; 
        __hk_start__ = . ;
        *(.hk .hk.*)  
    	. = ALIGN(4); 
        _ehk = . ; 
        __hk_end__ = . ;
    } > SRAM AT > FLASH

    .data : 
    { 
		_data_lma = LOADADDR(.data);
        _sdata = .; 
        __data_start__ = . ;
        *(.data .data.*) 
        . = ALIGN(4); 
        PROVIDE (__command_start = .);
    	*(.commands);
    	PROVIDE (__command_end = .);
    	. = ALIGN(4);
    	PROVIDE (__ram_persist_start = .);
    	*(.ram_persist);
    	PROVIDE (__ram_persist_end = .);
        . = ALIGN(4); 
        _edata = . ; 
        __data_end__ = . ;
    } > RAM AT >FLASH

    .bss (NOLOAD) : 
    { 
    	 __bss_start__ = .; 
        _sbss = . ; 
        *(.bss_begin .bss_begin.*)
        *(.bss .bss.*) 
        *(COMMON) 
        *(.bss_end .bss_end.*)
        . = ALIGN(4); 
         __bss_end__ = .; 
        _ebss = . ; 
    } > RAM AT >FLASH

    .noinit (NOLOAD) : ALIGN(4)
    {
        _noinit = .;
        
        *(.bss_end .bss_end.*)
        
         . = ALIGN(4) ;
        _end_noinit = .;   
    } > RAM
    
    __heap_start__ = .;
    __heap_limit__ = __stack - __Main_Stack_Size;
    
    /* Mandatory to be word aligned, _sbrk assumes this */
    PROVIDE ( end = _end_noinit ); /* was _ebss */
    PROVIDE ( _end = _end_noinit );
    PROVIDE ( __end = _end_noinit );
    PROVIDE ( __end__ = _end_noinit );
    
      DISCARD :
	  {
	    libc.a ( * )
	    libm.a ( * )
	    libgcc.a ( * )
	  }
}
    